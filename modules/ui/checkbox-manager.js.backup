// modules/ui/checkbox-manager.js - Clean Checkbox Logic
// Extracted from dashboard-manager.js to make debugging easier

export class CheckboxManager {
  constructor(searchQuerySSoT) {
    this.searchQuerySSoT = searchQuerySSoT;
    this.eventListeners = new Map(); // Track listeners for cleanup
    console.log('âœ… CheckboxManager: Focused checkbox handling module initialized');
  }

  // SAFE HTML entity decoding
  decodeHTMLEntities(value) {
    if (!value) return '';
    
    return value
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&amp;/g, '&');
  }

  // Attach event listeners to all checkboxes and labels
  attachCheckboxListeners() {
    console.log('ðŸ”— Attaching checkbox event listeners...');
    
    // Remove existing listeners first to prevent duplicates
    this.removeAllListeners();
    
    // Find all checkbox types
    const allCheckboxes = document.querySelectorAll('.smart-checkbox, .header-checkbox, .suggestion-checkbox');
    
    let attachedCount = 0;
    allCheckboxes.forEach((checkbox, index) => {
      if (!checkbox.dataset.listenerAttached) {
        // Attach change event to checkbox
        const changeHandler = (event) => this.handleCheckboxChange(event);
        checkbox.addEventListener('change', changeHandler);
        
        // Attach click event to the label
        const label = checkbox.closest('label');
        if (label && !label.dataset.labelListenerAttached) {
          const clickHandler = (event) => {
            // Prevent default to avoid double-clicking
            event.preventDefault();
            console.log('ðŸ–±ï¸ Pill clicked, toggling checkbox:', checkbox.value);
            
            // Toggle the checkbox
            checkbox.checked = !checkbox.checked;
            
            // Trigger change event
            const changeEvent = new Event('change', { bubbles: true });
            checkbox.dispatchEvent(changeEvent);
          };
          
          label.addEventListener('click', clickHandler);
          label.dataset.labelListenerAttached = 'true';
          
          // Track label listener for cleanup
          this.eventListeners.set(label, clickHandler);
        }
        
        // Track checkbox listener for cleanup
        this.eventListeners.set(checkbox, changeHandler);
        checkbox.dataset.listenerAttached = 'true';
        attachedCount++;
      }
    });
    
    console.log(`âœ… Attached ${attachedCount} new checkbox listeners (${allCheckboxes.length} total checkboxes)`);
    return attachedCount;
  }

  // Remove all event listeners
  removeAllListeners() {
    console.log('ðŸ§¹ Removing all checkbox and label listeners...');
    
    let removedCount = 0;
    this.eventListeners.forEach((handler, element) => {
      if (element.tagName === 'INPUT') {
        element.removeEventListener('change', handler);
        delete element.dataset.listenerAttached;
      } else if (element.tagName === 'LABEL') {
        element.removeEventListener('click', handler);
        delete element.dataset.labelListenerAttached;
      }
      removedCount++;
    });
    
    this.eventListeners.clear();
    console.log(`âœ… Removed ${removedCount} checkbox and label listeners`);
  }

  // Handle checkbox change events
  handleCheckboxChange(event) {
    const checkbox = event.target;
    const rawValue = checkbox.value;
    const decodedValue = this.decodeHTMLEntities(rawValue);
    const isChecked = checkbox.checked;
    
    console.log(`ðŸ”„ Checkbox changed: "${decodedValue}" (${isChecked ? 'CHECKED' : 'UNCHECKED'})`);
    console.log(`   Raw value: "${rawValue}"`);
    console.log(`   Decoded value: "${decodedValue}"`);
    
    // Get all current checkbox states
    const allSelectedTerms = this.getAllSelectedTerms();
    console.log('ðŸ“‹ All currently selected terms:', allSelectedTerms);
    
    // Update SSoT with new selections
    if (this.searchQuerySSoT) {
      this.searchQuerySSoT.updateUserSelections(allSelectedTerms);
      console.log('âœ… SSoT updated with user selections');
      
      // Trigger dashboard refresh if needed
      this.triggerDashboardRefresh();
    } else {
      console.error('âŒ SearchQuerySSoT not available for checkbox handling');
    }
  }

  // Get all currently selected terms from checkboxes
  getAllSelectedTerms() {
    const allCheckboxes = document.querySelectorAll('.smart-checkbox, .header-checkbox, .suggestion-checkbox');
    const selectedTerms = [];
    
    console.log(`ðŸ” Scanning ${allCheckboxes.length} checkboxes for selected terms...`);
    
    allCheckboxes.forEach((checkbox, index) => {
      if (checkbox.checked) {
        const rawValue = checkbox.value;
        const decodedValue = this.decodeHTMLEntities(rawValue);
        
        // Skip invalid or generic values
        if (!decodedValue || decodedValue === '0' || decodedValue === '1' || decodedValue === 'undefined') {
          console.log(`âš ï¸ Skipping invalid checkbox value: "${rawValue}"`);
          return;
        }
        
        selectedTerms.push(decodedValue);
        console.log(`âœ… Found selected term: "${decodedValue}" (from raw: "${rawValue}")`);
      }
    });
    
    console.log(`ðŸ“Š Total selected terms found: ${selectedTerms.length}`);
    return selectedTerms;
  }

  // Sync all checkboxes with current SSoT state
  syncAllCheckboxesWithSSoT() {
    if (!this.searchQuerySSoT) {
      console.log('âš ï¸ Cannot sync checkboxes - SearchQuerySSoT not available');
      return { syncedCount: 0, mismatchCount: 0 };
    }
    
    console.log('ðŸ”„ Syncing ALL checkbox instances with SSoT state...');
    
    const ssotSelectedTerms = this.searchQuerySSoT.getSelectedTerms() || [];
    console.log('ðŸ” SSoT selected terms for sync:', ssotSelectedTerms);
    
    const allCheckboxes = document.querySelectorAll('.smart-checkbox, .header-checkbox, .suggestion-checkbox');
    console.log(`ðŸ” Found ${allCheckboxes.length} checkboxes to potentially sync`);
    
    let syncedCount = 0;
    let mismatchCount = 0;
    
    allCheckboxes.forEach((checkbox, index) => {
      const rawValue = checkbox.value;
      const decodedValue = this.decodeHTMLEntities(rawValue);
      
      // Skip invalid checkboxes
      if (!decodedValue || decodedValue === '0' || decodedValue === '1' || decodedValue === 'undefined') {
        return;
      }
      
      console.log(`ðŸ” Checking checkbox ${index + 1}: "${decodedValue}"`);
      
      // Check if this term should be selected based on SSoT
      const shouldBeChecked = this.shouldCheckboxBeSelected(decodedValue, ssotSelectedTerms);
      
      // Update checkbox state if it doesn't match SSoT
      if (checkbox.checked !== shouldBeChecked) {
        console.log(`ðŸ”§ SYNC: "${decodedValue}" ${checkbox.checked ? 'CHECKED' : 'UNCHECKED'} â†’ ${shouldBeChecked ? 'CHECKED' : 'UNCHECKED'}`);
        checkbox.checked = shouldBeChecked;
        syncedCount++;
        mismatchCount++;
      } else {
        console.log(`âœ… MATCH: "${decodedValue}" already ${shouldBeChecked ? 'CHECKED' : 'UNCHECKED'}`);
      }
    });
    
    console.log(`âœ… Synced ${syncedCount} checkboxes with SSoT state`);
    if (syncedCount === 0) {
      console.log('â„¹ï¸ All checkboxes already in correct state (perfect sync!)');
    }
    
    return { syncedCount, mismatchCount, totalCheckboxes: allCheckboxes.length };
  }

  // Enhanced matching logic for SSoT terms vs checkbox values
  shouldCheckboxBeSelected(checkboxValue, ssotSelectedTerms) {
    // Use SSoT's smart quote matching if available
    if (this.searchQuerySSoT && this.searchQuerySSoT.isTermSelected) {
      const isSelected = this.searchQuerySSoT.isTermSelected(checkboxValue);
      console.log(`ðŸ§  SSoT smart matching: "${checkboxValue}" â†’ ${isSelected}`);
      return isSelected;
    }
    
    // Fallback to manual matching
    console.log(`âš ï¸ Using fallback matching for: "${checkboxValue}"`);
    
    const normalizedCheckboxValue = checkboxValue.toLowerCase().trim();
    
    for (const selectedTerm of ssotSelectedTerms) {
      const normalizedSelectedTerm = selectedTerm.toLowerCase().trim();
      
      // Direct match first
      if (normalizedSelectedTerm === normalizedCheckboxValue) {
        console.log(`âœ… EXACT match: "${checkboxValue}" = "${selectedTerm}"`);
        return true;
      }
      
      // Smart quote matching - handle quoted vs unquoted variants
      const selectedWithoutQuotes = selectedTerm.replace(/['"]/g, '').toLowerCase().trim();
      const checkboxWithoutQuotes = checkboxValue.replace(/['"]/g, '').toLowerCase().trim();
      
      if (selectedWithoutQuotes === checkboxWithoutQuotes) {
        console.log(`âœ… QUOTE match: "${checkboxValue}" â‰ˆ "${selectedTerm}"`);
        return true;
      }
    }
    
    console.log(`âŒ NO match: "${checkboxValue}" not found in SSoT selected terms`);
    return false;
  }

  // Trigger dashboard refresh after checkbox changes
  triggerDashboardRefresh() {
    // Emit custom event for dashboard to listen to
    const event = new CustomEvent('checkboxStateChanged', {
      detail: {
        timestamp: Date.now(),
        source: 'checkbox-manager'
      }
    });
    
    document.dispatchEvent(event);
    console.log('ðŸ“¡ Triggered dashboard refresh event');
    
    // CRITICAL: Also trigger search filter manager synchronization
    setTimeout(() => {
      if (window.auctionetExtension?.searchFilterManager) {
        console.log('ðŸ”„ Triggering SearchFilterManager synchronization...');
        window.auctionetExtension.searchFilterManager.synchronizePillsWithSSoT();
      }
    }, 50);
  }

  // Debug information
  debug() {
    console.log('ðŸ” CheckboxManager Debug Information:');
    
    const allCheckboxes = document.querySelectorAll('.smart-checkbox, .header-checkbox, .suggestion-checkbox');
    console.log('  Total checkboxes found:', allCheckboxes.length);
    console.log('  Event listeners attached:', this.eventListeners.size);
    
    const checkedCount = Array.from(allCheckboxes).filter(cb => cb.checked).length;
    console.log('  Currently checked:', checkedCount);
    
    // Show SSoT state
    if (this.searchQuerySSoT) {
      const ssotTerms = this.searchQuerySSoT.getSelectedTerms() || [];
      console.log('  SSoT selected terms:', ssotTerms.length);
      console.log('  SSoT terms:', ssotTerms);
    } else {
      console.log('  SSoT: Not available');
    }
    
    return {
      totalCheckboxes: allCheckboxes.length,
      checkedCheckboxes: checkedCount,
      eventListeners: this.eventListeners.size,
      ssotAvailable: !!this.searchQuerySSoT
    };
  }

  // Cleanup on destruction
  destroy() {
    console.log('ðŸ§¹ CheckboxManager: Cleaning up...');
    this.removeAllListeners();
    this.searchQuerySSoT = null;
  }
} 