// content.js - Universal Content Script for Auctionet Extension
// Handles both edit and add pages
//
// LANGUAGE REQUIREMENTS:
// - All user-facing text (tooltips, messages, AI responses) must be in Swedish
// - Code comments and console logs should be in English
// - Technical field names and JSON keys remain in English for parsing

console.log('üöÄ Auctionet AI Assistant: Content script loaded!');

// Import the API Bridge that connects add page to edit page API manager
import('./modules/add-items-api-bridge.js').then(module => {
  window.AddItemsAPIBridge = module.AddItemsAPIBridge;
}).catch(error => {
  console.error('‚ùå Failed to load AddItemsAPIBridge:', error);
});

// Import the new modular tooltip system components
import('./modules/ui/tooltip-system-manager.js').then(module => {
  window.TooltipSystemManager = module.TooltipSystemManager;
}).catch(error => {
  console.error('‚ùå Failed to load TooltipSystemManager:', error);
});

import('./modules/core/field-quality-analyzer.js').then(module => {
  window.FieldQualityAnalyzer = module.FieldQualityAnalyzer;
}).catch(error => {
  console.error('‚ùå Failed to load FieldQualityAnalyzer:', error);
});

import('./modules/ui/field-monitor-manager.js').then(module => {
  window.FieldMonitorManager = module.FieldMonitorManager;
}).catch(error => {
  console.error('‚ùå Failed to load FieldMonitorManager:', error);
});

import('./modules/add-items-integration-manager.js').then(module => {
  window.AddItemsIntegrationManager = module.AddItemsIntegrationManager;
}).catch(error => {
  console.error('‚ùå Failed to load AddItemsIntegrationManager:', error);
});

// Monitor for DOM changes to detect page transitions
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
      // Check if we're now on a supported page
      setTimeout(() => {
        if (!window.auctionetAssistantInitialized) {
          window.auctionetAssistant?.tryInitialize?.();
        }
      }, 500);
    }
  });
});

observer.observe(document.body, { childList: true, subtree: true });

class AuctionetCatalogingAssistant {
  constructor() {
    this.apiKey = null;
    this.currentPage = null;
    this.tooltipManager = null;
    this.isProgrammaticUpdate = false; // Track when we're updating fields programmatically
    
    // Initialize asynchronously to prevent blocking
    this.init().catch(error => {
      console.error('‚ùå Failed to initialize AuctionetCatalogingAssistant:', error);
    });
    
    // Listen for API key changes
    chrome.storage.onChanged.addListener((changes, namespace) => {
      if (namespace === 'sync' && changes.anthropicApiKey) {
        this.apiKey = changes.anthropicApiKey.newValue;
      }
    });
    
    // Listen for messages from popup
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
      if (request.type === 'refresh-api-key') {
        this.loadApiKey();
        sendResponse({ success: true });
      }
    });
  }

  async init() {
    // Wait for page to be fully loaded
    if (document.readyState === 'loading') {
      await new Promise(resolve => {
        document.addEventListener('DOMContentLoaded', resolve);
      });
    }

    // Additional wait to ensure dynamic content is loaded
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Check if we're on the right page and determine page type
    const pageInfo = this.detectPageType();
    
    if (!pageInfo.isSupported) {
      return;
    }

    this.currentPage = pageInfo.type;
    console.log('‚úÖ Auctionet AI Assistant: On supported page, type:', this.currentPage);
    
    await this.loadApiKey();
    
    if (this.currentPage === 'edit') {
      // üèóÔ∏è NEW: Initialize Edit Page Orchestrator (Progressive Migration)
      await this.initializeEditPageOrchestrator();
      
      // Legacy UI initialization (will be migrated to orchestrator)
      this.injectUI();
      this.attachEventListeners();
    } else if (this.currentPage === 'add') {
      await this.initializeAddItemsTooltips();
    }
  }

  detectPageType() {
    const url = window.location.href;
    const hash = window.location.hash;
    
    // Check for edit page
    if (url.includes('auctionet.com/admin/') && 
        url.includes('/items/') && 
        url.includes('/edit') &&
        document.querySelector('#item_title_sv')) {
      return { isSupported: true, type: 'edit' };
    }
    
    // Check for add items page - NEW URL PATTERN
    if (url.includes('auctionet.com/admin/sas/sellers/') && 
        url.includes('/contracts/') &&
        hash === '#new_item' &&
        document.querySelector('#item_title_sv')) {
      return { isSupported: true, type: 'add' };
    }
    
    // Legacy check for old add items URL pattern (fallback)
    if (url.includes('auctionet.com/admin/') && 
        url.includes('/items/new') &&
        document.querySelector('#item_title_sv')) {
      return { isSupported: true, type: 'add' };
    }
    
    return { isSupported: false, type: null };
  }

  async initializeAddItemsTooltips() {
    try {
      console.log('üéØ Initializing Add Items with new modular components...');
      
      // Wait for all required classes to be loaded via dynamic imports
      if (!window.AddItemsAPIBridge || !window.TooltipSystemManager || !window.FieldQualityAnalyzer || !window.FieldMonitorManager || !window.AddItemsIntegrationManager) {
        await new Promise(resolve => {
          const checkForClasses = () => {
            if (window.AddItemsAPIBridge && window.TooltipSystemManager && window.FieldQualityAnalyzer && window.FieldMonitorManager && window.AddItemsIntegrationManager) {
              console.log('‚úÖ Dynamic imports loaded successfully');
              resolve();
            } else {
              setTimeout(checkForClasses, 100);
            }
          };
          checkForClasses();
        });
      }

      // üéØ NEW: Use API Bridge that connects to edit page API manager
      console.log('üöÄ Creating API Bridge with edit page integration...');
      const apiBridge = new window.AddItemsAPIBridge();
      await apiBridge.init();

      // Initialize new modular components
      console.log('üéØ Initializing modular tooltip system components...');
      
      // Create the tooltip system manager
      this.tooltipSystemManager = new window.TooltipSystemManager();
      this.tooltipSystemManager.init();
      
      // Create the field quality analyzer
      this.fieldQualityAnalyzer = new window.FieldQualityAnalyzer();
      this.fieldQualityAnalyzer.setApiManager(apiBridge.getAPIManager());
      
      // Create the field monitor manager
      this.fieldMonitorManager = new window.FieldMonitorManager();
      this.fieldMonitorManager.init({
        tooltipSystemManager: this.tooltipSystemManager,
        fieldQualityAnalyzer: this.fieldQualityAnalyzer,
        apiBridge: apiBridge
      });
      
      // Create the integration manager to handle UI features
      this.integrationManager = new window.AddItemsIntegrationManager();
      this.integrationManager.init({
        apiBridge: apiBridge,
        tooltipSystemManager: this.tooltipSystemManager,
        fieldQualityAnalyzer: this.fieldQualityAnalyzer,
        fieldMonitorManager: this.fieldMonitorManager
      });
      
      // Store the bridge for potential future use
      this.apiBridge = apiBridge;
      
      console.log('‚úÖ Add items system initialized with new modular components');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize add items with modular components:', error);
    }
  }

  async initializeEditPageOrchestrator() {
    try {
      console.log('üèóÔ∏è Initializing Edit Page Orchestrator...');
      
      // Dynamic import of the Edit Page Orchestrator and SearchQuerySSoT
      const orchestratorModule = await import('./pages/edit-page-orchestrator.js');
      const { SearchQuerySSoT } = await import('./modules/search-query-ssot.js');
      
      // Create and initialize the orchestrator
      this.editPageOrchestrator = new orchestratorModule.EditPageOrchestrator();
      
      // Set up API manager (using existing quality-analyzer.js API manager for now)
      const apiManager = this.createAPIManager();
      this.editPageOrchestrator.setApiManager(apiManager);
      
      // Initialize AI-only SearchQuerySSoT (following content-script.js pattern)
      this.searchQuerySSoT = new SearchQuerySSoT(apiManager);
      console.log('ü§ñ AI-only SearchQuerySSoT initialized for edit page');
      
      // Wire SearchQuerySSoT to orchestrator
      this.editPageOrchestrator.setSearchQuerySSoT(this.searchQuerySSoT);
      
      // Initialize SearchQuerySSoT if needed from global scope
      if (window.searchQuerySSoT) {
        this.editPageOrchestrator.setSearchQuerySSoT(window.searchQuerySSoT);
      }
      
      // Initialize the orchestrator
      await this.editPageOrchestrator.initialize();
      
      console.log('‚úÖ Edit Page Orchestrator initialized successfully');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize Edit Page Orchestrator:', error);
      console.log('üîÑ Falling back to legacy quality-analyzer.js');
    }
  }

  createAPIManager() {
    // TODO: This should be extracted from quality-analyzer.js
    // For now, create a simple wrapper that delegates to the legacy system
    const parentClass = this;
    
    const apiManager = {
      apiKey: this.apiKey,
      searchQuerySSoT: null,
      
      async callClaudeAPI(itemData, fieldType, retryCount = 0) {
        return await parentClass.callClaudeAPI(itemData, fieldType, retryCount);
      },
      
      async analyzeForArtist(title, objectType, artistField, description = '') {
        console.log('ü§ñ API Manager: Analyzing for artist in title:', title);
        
        if (!parentClass.apiKey) {
          console.error('ü§ñ API Manager: No API key available');
          return { hasArtist: false };
        }
        
        const prompt = `Analyze this Swedish auction title for potential artist names that should be moved to the artist field.

IMPORTANT: If you detect a misspelled artist name, correct it and explain the correction. Do NOT reject misspellings - instead provide the correct spelling with reasoning.

LANGUAGE REQUIREMENT: All user-facing text (reasoning, explanations) must be in Swedish. Only field names in JSON should remain in English.

CRITICAL JSON FORMATTING:
- ALWAYS escape quotes in JSON string values using backslashes
- If title contains "quotes", write them as \"quotes\" in JSON
- Example: "suggestedTitle": "\"Nornan\" f√§rglitografi signerad numrerad 55/150"
- NEVER use unescaped quotes inside JSON string values

Title: "${title}"
Current artist field: "${artistField}"
Object type: "${objectType || 'unknown'}"
Description: "${description}"

GUIDELINES:
- Detect and CORRECT misspelled Swedish artist names (e.g., "Rolf Lidbergg" ‚Üí "Rolf Lidberg")
- If name appears misspelled, research the correct spelling and provide it
- Use confidence 0.7-0.9 for corrections (high confidence in correction)
- Use confidence 0.4-0.6 for uncertain detections
- Move artist name to artist field, provide clean title without artist name
- Respond in Swedish for all user-facing text (reasoning)

CRITICAL: Escape ALL quotes in JSON string values with backslashes!

RESPOND WITH VALID JSON:
{
  "hasArtist": boolean,
  "artistName": "corrected name or null",
  "confidence": 0.0-1.0,
  "suggestedTitle": "title without artist, quotes properly escaped",
  "reasoning": "explanation in Swedish"
}`;

        try {
          // Make direct API call using background script communication
          const response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({
              type: 'anthropic-fetch',
              apiKey: parentClass.apiKey,
              body: {
                model: 'claude-3-haiku-20240307',
                max_tokens: 1000,
                temperature: 0.3,
                system: 'You are an expert Swedish auction cataloger specializing in artist detection. Respond only with valid JSON.',
                messages: [{
                  role: 'user',
                  content: [{ type: 'text', text: prompt }]
                }]
              }
            }, (response) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else if (response.success) {
                resolve(response);
              } else {
                reject(new Error(response.error || 'API request failed'));
              }
            });
          });
          
          // Validate response structure
          if (!response.data || !response.data.content || !Array.isArray(response.data.content) || response.data.content.length === 0) {
            console.error('ü§ñ API Manager: Invalid response format from API');
            return { hasArtist: false };
          }
          
          if (!response.data.content[0] || !response.data.content[0].text) {
            console.error('ü§ñ API Manager: No text content in API response');
            return { hasArtist: false };
          }
          
          const rawResponse = response.data.content[0].text;
          console.log('ü§ñ API Manager: Raw artist analysis response:', rawResponse);
          
          // Parse the JSON response
          try {
            const result = JSON.parse(rawResponse);
            console.log('ü§ñ API Manager: Parsed artist analysis result:', result);
            return result;
          } catch (parseError) {
            console.error('ü§ñ API Manager: Failed to parse artist analysis JSON:', parseError);
            console.error('ü§ñ API Manager: Raw response that failed to parse:', rawResponse);
            return { hasArtist: false };
          }
          
        } catch (error) {
          console.error('‚ùå API Manager: analyzeForArtist failed:', error);
          return { hasArtist: false };
        }
      },
      
      // CRITICAL FIX: Add analyzeItemData method for BrandValidationManager
      async analyzeItemData(prompt) {
        if (!parentClass.apiKey) {
          throw new Error('No API key available');
        }
        
        try {
          // Use background script to make API call to avoid CORS issues
          const response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({
              type: 'anthropic-fetch',
              apiKey: parentClass.apiKey,
              body: {
                model: 'claude-3-haiku-20240307',
                max_tokens: 1000,
                temperature: 0.3,
                system: 'You are an expert Swedish auction cataloger specializing in brand validation. Respond only with valid JSON.',
                messages: [{
                  role: 'user',
                  content: [{ type: 'text', text: prompt }]
                }]
              }
            }, (response) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else if (response.success) {
                resolve(response);
              } else {
                reject(new Error(response.error || 'API request failed'));
              }
            });
          });
          
          // Validate response structure
          if (!response.data || !response.data.content || !Array.isArray(response.data.content) || response.data.content.length === 0) {
            throw new Error('Invalid response format from API');
          }
          
          if (!response.data.content[0] || !response.data.content[0].text) {
            throw new Error('No text content in API response');
          }
          
          return response.data.content[0].text;
          
        } catch (error) {
          console.error('‚ùå analyzeItemData API call failed:', error);
          throw error;
        }
      },
      
      setSearchQuerySSoT(searchQuerySSoT) {
        this.searchQuerySSoT = searchQuerySSoT;
        console.log('üîó API Manager: SearchQuerySSoT connected');
      },
      
      getSearchQuerySSoT() {
        return this.searchQuerySSoT;
      },
      
      // Add market analysis method for dashboard
      async analyzeSales(searchContext) {
        console.log('üìä API Manager: analyzeSales not yet implemented, returning mock data for dashboard');
        
        // Return mock data structure for now
        return {
          hasComparableData: true,
          priceRange: {
            low: 5000,
            high: 15000
          },
          confidence: 0.7,
          dataSource: 'Mock Auctionet API',
          historical: {
            totalSales: 25,
            averagePrice: 8500,
            timeRange: 'Senaste 2 √•ren'
          },
          insights: [
            'Stabilt intresse f√∂r denna typ av objekt',
            'Priserna har varit relativt konstanta'
          ]
        };
      },
      
      // CRITICAL FIX: Add missing verifyArtist method that ArtistDetectionManager needs
      async verifyArtist(artistName, objectType, period) {
        console.log('üéØ API Manager: Verifying artist:', artistName);
        
        if (!parentClass.apiKey) {
          console.log('‚ö†Ô∏è No API key available for artist verification');
          return null;
        }

        try {
          const prompt = `Verifiera denna potentiella konstn√§r/designer:

NAMN: "${artistName}"
OBJEKTTYP: ${objectType || 'Ok√§nd'}
PERIOD: ${period || 'Ok√§nd'}

UPPGIFT:
√Ñr detta en verklig konstn√§r, designer eller hantverkare? Ge biografisk kontext om m√∂jligt.

SVARA MED JSON:
{
  "isRealArtist": boolean,
  "confidence": 0.0-1.0,
  "biography": "kort biografisk information eller null",
  "specialties": ["lista", "√∂ver", "specialiteter"] eller null,
  "activeYears": "aktiva √•r eller null",
  "relevanceToObject": "relevans till objekttyp eller null"
}`;

          const response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({
              type: 'anthropic-fetch',
              apiKey: parentClass.apiKey,
              body: {
                model: 'claude-3-haiku-20240307',
                max_tokens: 400,
                temperature: 0.1,
                messages: [{
                  role: 'user',
                  content: prompt
                }]
              }
            }, (response) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else if (response.success) {
                resolve(response);
              } else {
            reject(new Error(response.error || 'API request failed'));
          }
        });
      });
      
      return await this.processAPIResponse(response, systemPrompt, userPrompt, fieldType);
      
    } catch (error) {
      // Handle rate limiting and overload errors with retry
      if ((error.message.includes('Overloaded') || error.message.includes('rate limit') || error.message.includes('429')) && retryCount < 3) {
        const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff: 1s, 2s, 4s
        console.log(`API overloaded, retrying in ${delay}ms (attempt ${retryCount + 1}/3)`);
        
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.callClaudeAPI(itemData, fieldType, retryCount + 1);
      }
      
      // If it's an overload error and we've exhausted retries, provide helpful message
      if (error.message.includes('Overloaded')) {
        throw new Error('Claude API √§r √∂verbelastad just nu. V√§nta en stund och f√∂rs√∂k igen.');
      }
      
      throw error;
    }
  }

  async processAPIResponse(response, systemPrompt, userPrompt, fieldType) {

    const data = response.data;
    console.log('Received API response:', data);
    
    // Validate response structure
    if (!data || !data.content || !Array.isArray(data.content) || data.content.length === 0) {
      throw new Error('Invalid response format from API');
    }
    
    if (!data.content[0] || !data.content[0].text) {
      throw new Error('No text content in API response');
    }
    
    let result = this.parseClaudeResponse(data.content[0].text, fieldType);
    
    // If validation failed, retry with correction instructions (only for multi-field requests)
    if (result.needsCorrection && ['all', 'all-enhanced', 'all-sparse'].includes(fieldType)) {
      const correctionPrompt = `
De f√∂reg√•ende f√∂rslagen klarade inte kvalitetskontrollen:
Po√§ng: ${result.validationScore}/100

FEL SOM M√ÖSTE R√ÑTTAS:
${result.validationErrors.join('\n')}

F√ñRB√ÑTTRINGSF√ñRSLAG:
${result.validationWarnings.join('\n')}

V√§nligen korrigera dessa problem och returnera f√∂rb√§ttrade versioner som f√∂ljer alla svenska auktionsstandarder.
`;
      
      const correctionResponse = await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage({
          type: 'anthropic-fetch',
          apiKey: this.apiKey,
          body: {
            model: 'claude-3-5-sonnet-20241022', // Fixed from invalid model name
            max_tokens: 1500,
            temperature: 0.1,
            system: systemPrompt,
            messages: [
              { role: 'user', content: userPrompt },
              { role: 'assistant', content: data.content[0].text },
              { role: 'user', content: correctionPrompt }
            ]
          }
        }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else if (response.success) {
            resolve(response);
          } else {
            reject(new Error(response.error || 'API request failed'));
          }
        });
      });
      
      if (correctionResponse.success) {
        const correctionData = correctionResponse.data;
        console.log('Received correction response:', correctionData);
        
        // Validate correction response structure
        if (correctionData && correctionData.content && correctionData.content[0] && correctionData.content[0].text) {
          result = this.parseClaudeResponse(correctionData.content[0].text, fieldType);
        } else {
          console.warn('Invalid correction response format, using original result');
        }
      }
    }
    
    return result;
  }

  getSystemPrompt() {
    return `Du √§r en professionell auktionskatalogiserare. Skapa objektiva, faktabaserade katalogiseringar enligt svenska auktionsstandarder.

GRUNDREGLER:
‚Ä¢ Anv√§nd endast verifierbara fakta
‚Ä¢ Skriv objektivt utan s√§ljande spr√•k
‚Ä¢ Anv√§nd etablerad auktionsterminologi
‚Ä¢ UPPFINN ALDRIG information som inte finns

F√ñRBJUDET:
‚Ä¢ S√§ljande uttryck: "vacker", "fantastisk", "unik", "s√§llsynt"
‚Ä¢ Meta-kommentarer: "ytterligare uppgifter beh√∂vs", "mer information kr√§vs"
‚Ä¢ Spekulationer och gissningar

TITELFORMAT (max 60 tecken):
Om konstn√§r-f√§lt tomt: [KONSTN√ÑR], [F√∂rem√•l], [Material], [Period]
Om konstn√§r-f√§lt ifyllt: [F√∂rem√•l], [Material], [Period]

OS√ÑKERHETSMARK√ñRER - BEH√ÖLL ALLTID:
"troligen", "tillskriven", "efter", "stil av", "m√∂jligen"

KONDITION - KRITISKA REGLER:
‚Ä¢ Anv√§nd korta, faktabaserade termer: "V√§lbevarat", "Mindre repor", "Nagg vid kanter"
‚Ä¢ UPPFINN ALDRIG nya skador, placeringar eller detaljer
‚Ä¢ Om original s√§ger "repor" - skriv INTE "repor i metallramen" eller "repor p√• ytan"
‚Ä¢ L√§gg ALDRIG till specifika platser som "i metallramen", "p√• ovansidan", "vid foten"
‚Ä¢ F√∂rb√§ttra ENDAST spr√•ket - l√§gg INTE till nya faktauppgifter

STRIKT ANTI-HALLUCINATION:
‚Ä¢ F√∂rb√§ttra ENDAST spr√•k och struktur av BEFINTLIG information
‚Ä¢ L√§gg INTE till material, m√•tt, skador, placeringar som inte √§r n√§mnda
‚Ä¢ Kopiera EXAKT samma skadeinformation som redan finns
‚Ä¢ Katalogtext ska vara F√ÑRDIG utan √∂nskem√•l om mer data
‚Ä¢ ALDRIG l√§gga till detaljer f√∂r att "f√∂rb√§ttra" - bara f√∂rb√§ttra spr√•ket`;
  }

  getUserPrompt(itemData, fieldType) {
    const baseInfo = `
F√ñREM√ÖLSINFORMATION:
Kategori: ${itemData.category}
Nuvarande titel: ${itemData.title}
Nuvarande beskrivning: ${itemData.description}
Kondition: ${itemData.condition}
Konstn√§r/Formgivare: ${itemData.artist}
V√§rdering: ${itemData.estimate} SEK

VIKTIGT F√ñR TITEL: ${itemData.artist ? 
  'Konstn√§r/formgivare-f√§ltet √§r ifyllt (' + itemData.artist + '), s√• inkludera INTE konstn√§rens namn i titeln - det l√§ggs till automatiskt av systemet.' : 
  'Konstn√§r/formgivare-f√§ltet √§r tomt, s√• inkludera konstn√§rens namn i titeln om det √§r k√§nt.'}

KONSTN√ÑRSINFORMATION F√ñR TIDSPERIOD:
${itemData.artist ? 
  'Konstn√§r/formgivare: ' + itemData.artist + ' - Anv√§nd din kunskap om denna konstn√§rs aktiva period f√∂r att best√§mma korrekt tidsperiod. Om du inte √§r s√§ker, anv√§nd "troligen" eller utel√§mna period.' : 
  'Ingen konstn√§r angiven - l√§gg INTE till tidsperiod om den inte redan finns i k√§lldata.'}

KRITISKT - BEH√ÖLL OS√ÑKERHETSMARK√ñRER I TITEL:
Om nuvarande titel inneh√•ller ord som "troligen", "tillskriven", "efter", "stil av", "m√∂jligen", "typ" - BEH√ÖLL dessa exakt. De anger juridisk os√§kerhet och f√•r ALDRIG tas bort eller √§ndras.

ANTI-HALLUCINATION INSTRUKTIONER:
‚Ä¢ L√§gg ALDRIG till information som inte finns i k√§lldata
‚Ä¢ Uppfinn ALDRIG tidsperioder, material, m√•tt eller skador
‚Ä¢ F√∂rb√§ttra ENDAST spr√•k, struktur och terminologi
‚Ä¢ Om information saknas - utel√§mna eller anv√§nd os√§kerhetsmark√∂rer
`;

    if (fieldType === 'all') {
      return baseInfo + `
UPPGIFT: F√∂rb√§ttra titel, beskrivning, konditionsrapport och generera dolda s√∂kord enligt svenska auktionsstandarder.

KRITISKT - F√ÑLTAVGR√ÑNSNING:
‚Ä¢ BESKRIVNING: Material, teknik, m√•tt, stil, ursprung, m√§rkningar, funktion - ALDRIG konditionsinformation
‚Ä¢ KONDITION: Endast fysiskt skick och skador - ALDRIG beskrivande information
‚Ä¢ H√•ll f√§lten strikt separerade - konditionsdetaljer som "slitage", "repor", "m√§rken" h√∂r ENDAST i konditionsf√§ltet
‚Ä¢ Om konditionsinformation finns i nuvarande beskrivning - flytta den till konditionsf√§ltet

KRITISKT - ANTI-HALLUCINATION REGLER:
‚Ä¢ L√§gg ALDRIG till information som inte finns i k√§lldata
‚Ä¢ Uppfinn INTE tidsperioder, material, m√•tt eller skador
‚Ä¢ Anv√§nd konstn√§rsinformation f√∂r tidsperiod ENDAST om du √§r s√§ker
‚Ä¢ F√∂rb√§ttra ENDAST spr√•k, struktur och terminologi av befintlig information
‚Ä¢ L√§gg ALDRIG till kommentarer om vad som "beh√∂vs", "saknas" eller "kr√§vs"
‚Ä¢ Skriv INTE fraser som "ytterligare uppgifter beh√∂vs" eller "mer information kr√§vs"
‚Ä¢ Katalogtext ska vara F√ÑRDIG och KOMPLETT utan √∂nskem√•l om mer data

Returnera EXAKT i detta format (en rad per f√§lt):
TITEL: [f√∂rb√§ttrad titel]
BESKRIVNING: [f√∂rb√§ttrad beskrivning utan konditionsinformation]
KONDITION: [f√∂rb√§ttrad konditionsrapport]
S√ñKORD: [relevanta s√∂kord separerade med mellanslag, anv√§nd "-" f√∂r flerordsfraser]
VALIDERING: [kvalitetspo√§ng och eventuella varningar]

VIKTIGT F√ñR S√ñKORD: Anv√§nd kommatecken f√∂r att separera s√∂kord.
EXEMPEL: "konstglas, mundbl√•st, svensk design, 1960-tal, samlarobjekt"

Anv√§nd INTE markdown formatering eller extra tecken som ** eller ***. Skriv bara ren text.`;
    } else if (fieldType === 'all-enhanced' && itemData.additionalInfo) {
      return baseInfo + `
YTTERLIGARE INFORMATION:
Material: ${itemData.additionalInfo.material}
Teknik: ${itemData.additionalInfo.technique}
M√§rkningar: ${itemData.additionalInfo.markings}
Specifika skador: ${itemData.additionalInfo.damage}
√ñvrigt: ${itemData.additionalInfo.additional}

UPPGIFT: Anv√§nd all tillg√§nglig information f√∂r att skapa professionell katalogisering.

ANTI-HALLUCINATION REGLER:
‚Ä¢ Anv√§nd ENDAST den information som angivits ovan
‚Ä¢ L√§gg INTE till ytterligare detaljer som inte √§r n√§mnda
‚Ä¢ Kombinera k√§lldata med till√§ggsinfo p√• ett faktabaserat s√§tt
‚Ä¢ L√§gg ALDRIG till kommentarer om vad som "beh√∂vs" eller "saknas"
‚Ä¢ Katalogtext ska vara F√ÑRDIG och KOMPLETT

Returnera EXAKT i detta format (en rad per f√§lt):
TITEL: [f√∂rb√§ttrad titel med korrekt material]
BESKRIVNING: [detaljerad beskrivning med all relevant information]
KONDITION: [specifik konditionsrapport baserad p√• angiven information]
S√ñKORD: [omfattande s√∂kord baserade p√• all information]
VALIDERING: [kvalitetspo√§ng och f√∂rb√§ttringar]

Anv√§nd INTE markdown formatering eller extra tecken som ** eller ***. Skriv bara ren text.`;
    } else if (fieldType === 'all-sparse') {
      return baseInfo + `
UPPGIFT: Informationen √§r mycket knapph√§ndig. G√∂r ditt b√§sta f√∂r att f√∂rb√§ttra baserat p√• tillg√§nglig information, men markera var mer information beh√∂vs.

KRITISKT - SPARSE DATA REGLER:
‚Ä¢ F√∂rb√§ttra ENDAST spr√•k och struktur av befintlig information
‚Ä¢ L√§gg ALDRIG till p√•hittade detaljer f√∂r att fylla ut texten
‚Ä¢ Om information saknas - l√§mna tomt eller anv√§nd os√§kerhetsmark√∂rer
‚Ä¢ L√§gg ALDRIG till kommentarer om vad som "beh√∂vs" eller "saknas" i katalogtext
‚Ä¢ Katalogtext ska vara F√ÑRDIG och KOMPLETT utan √∂nskem√•l om mer data

Returnera EXAKT i detta format (en rad per f√§lt):
TITEL: [f√∂rb√§ttrad titel]
BESKRIVNING: [f√∂rb√§ttrad beskrivning]
KONDITION: [f√∂rb√§ttrad konditionsrapport]
S√ñKORD: [generera s√• m√•nga relevanta s√∂kord som m√∂jligt]
VALIDERING: [kvalitetspo√§ng och eventuella varningar]

Anv√§nd INTE markdown formatering eller extra tecken som ** eller ***. Skriv bara ren text.`;
    } else if (fieldType === 'title') {
      return baseInfo + `
UPPGIFT: F√∂rb√§ttra endast titeln enligt svenska auktionsstandarder. Max 60 tecken.

KRITISKT VIKTIGT - BEH√ÖLL OS√ÑKERHETSMARK√ñRER:
Om originaltiteln inneh√•ller "troligen", "tillskriven", "efter", "stil av", "m√∂jligen", "typ", "skola av", eller "krets kring" - BEH√ÖLL dessa ord exakt som de √§r. De anger juridisk os√§kerhet och f√•r ALDRIG tas bort.

ANTI-HALLUCINATION F√ñR TITEL:
‚Ä¢ L√§gg INTE till tidsperiod om den inte finns i originaldata ELLER kan h√§rledas fr√•n k√§nd konstn√§r
‚Ä¢ L√§gg INTE till material som inte √§r n√§mnt
‚Ä¢ L√§gg INTE till platser eller tillverkare som inte √§r angivna
‚Ä¢ F√∂rb√§ttra ENDAST struktur, stavning och terminologi

EXEMPEL:
Original: "TALLRIK, fajans, troligen Matet, Martres-Tolosane, Frankrike, 18/1900-tal"
Korrekt: "TALLRIK, fajans, troligen Matet, Martres-Tolosane, 18/1900-tal"
FEL: "TALLRIK, fajans, Matet, Martres-Tolosane, 18/1900-tal" (troligen borttaget)

Returnera ENDAST den f√∂rb√§ttrade titeln utan extra formatering eller etiketter.`;
    } else if (fieldType === 'description') {
      return baseInfo + `
UPPGIFT: F√∂rb√§ttra endast beskrivningen. Inkludera m√•tt om de finns, anv√§nd korrekt terminologi.

KRITISKT - F√ÑLTAVGR√ÑNSNING F√ñR BESKRIVNING:
‚Ä¢ Inkludera ALDRIG konditionsinformation i beskrivningen
‚Ä¢ Konditionsdetaljer som "slitage", "repor", "m√§rken", "skador", "nagg", "sprickor", "fl√§ckar" h√∂r ENDAST hemma i konditionsf√§ltet
‚Ä¢ Beskrivningen ska fokusera p√•: material, teknik, m√•tt, stil, ursprung, m√§rkningar, funktion
‚Ä¢ EXEMPEL P√Ö F√ñRBJUDET I BESKRIVNING: "Slitage f√∂rekommer", "repor och m√§rken", "normalt √•ldersslitage", "mindre skador"
‚Ä¢ Om konditionsinformation finns i nuvarande beskrivning - TA BORT den och beh√•ll endast beskrivande information

ANTI-HALLUCINATION F√ñR BESKRIVNING:
‚Ä¢ L√§gg INTE till m√•tt som inte √§r angivna
‚Ä¢ L√§gg INTE till material som inte √§r n√§mnt
‚Ä¢ L√§gg INTE till tekniker som inte √§r beskrivna
‚Ä¢ L√§gg INTE till m√§rkningar eller signaturer som inte finns
‚Ä¢ F√∂rb√§ttra ENDAST spr√•k, struktur och befintlig information
‚Ä¢ L√§gg ALDRIG till kommentarer om vad som "saknas" eller "beh√∂vs"
‚Ä¢ Skriv INTE fraser som "ytterligare uppgifter beh√∂vs" eller "information saknas"

Returnera ENDAST den f√∂rb√§ttrade beskrivningen utan extra formatering eller etiketter.`;
    } else if (fieldType === 'condition') {
      return baseInfo + `
UPPGIFT: F√∂rb√§ttra konditionsrapporten. Skriv KORT och FAKTABASERAT. Anv√§nd endast standardtermer. Max 2-3 korta meningar.

KRITISKT - F√ÑLTAVGR√ÑNSNING F√ñR KONDITION:
‚Ä¢ Fokusera ENDAST p√• fysiskt skick och skador
‚Ä¢ Inkludera ALDRIG beskrivande information om material, teknik, stil eller funktion
‚Ä¢ Konditionsrapporten ska vara separat fr√•n beskrivningen
‚Ä¢ Anv√§nd specifika konditionstermer: "repor", "nagg", "sprickor", "fl√§ckar", "v√§lbevarat", "mindre skador"
‚Ä¢ UNDVIK vaga termer som endast "bruksslitage" - var specifik

KRITISKT - ANTI-HALLUCINATION F√ñR KONDITION:
‚Ä¢ Beskriv ENDAST skador/slitage som redan √§r n√§mnda i nuvarande kondition
‚Ä¢ L√§gg ALDRIG till specifika placeringar som "i metallramen", "p√• ovansidan", "vid foten" om inte redan angivet
‚Ä¢ L√§gg ALDRIG till specifika m√•tt som "repor 3cm" om inte angivet
‚Ä¢ L√§gg ALDRIG till nya defekter, material eller delar som inte n√§mns
‚Ä¢ L√§gg ALDRIG till detaljer om VAR skadorna finns om det inte redan st√•r i originalet
‚Ä¢ EXEMPEL P√Ö F√ñRBJUDET: Om original s√§ger "repor" - skriv INTE "repor i metallramen" eller "repor p√• ytan"
‚Ä¢ F√∂rb√§ttra ENDAST spr√•k och anv√§nd standardtermer f√∂r EXAKT samma information som redan finns
‚Ä¢ Om originalet s√§ger "bruksslitage" - f√∂rb√§ttra till "normalt bruksslitage" eller "synligt bruksslitage", INTE "repor och m√§rken"
‚Ä¢ L√§gg ALDRIG till kommentarer om vad som "beh√∂vs" eller "saknas"
‚Ä¢ Skriv INTE fraser som "ytterligare uppgifter beh√∂vs" eller "mer information kr√§vs"

STRIKT REGEL: Kopiera ENDAST den skadeinformation som redan finns - l√§gg ALDRIG till nya detaljer.

EXEMPEL P√Ö KORREKT F√ñRB√ÑTTRING:
Original: "bruksslitage" ‚Üí F√∂rb√§ttrat: "Normalt bruksslitage"
Original: "repor" ‚Üí F√∂rb√§ttrat: "Mindre repor" (INTE "repor i metallramen")
Original: "slitage f√∂rekommer" ‚Üí F√∂rb√§ttrat: "Synligt slitage"

UNDVIK: L√•nga beskrivningar, f√∂rklaringar av tillverkningstekniker, v√§rderande kommentarer, p√•hittade skador, specifika placeringar.

Returnera ENDAST den f√∂rb√§ttrade konditionsrapporten utan extra formatering eller etiketter.`;
    } else if (fieldType === 'keywords') {
      return baseInfo + `
UPPGIFT: Generera H√ñGKVALITATIVA dolda s√∂kord som kompletterar titel och beskrivning enligt Auctionets format.

KRITISKT - UNDVIK ALLA UPPREPNINGAR:
‚Ä¢ Generera ENDAST s√∂kord som INTE redan finns i nuvarande titel/beskrivning
‚Ä¢ L√§s noggrant igenom titel och beskrivning INNAN du skapar s√∂kord
‚Ä¢ Om ordet redan finns n√•gonstans - anv√§nd det INTE
‚Ä¢ Fokusera p√• HELT NYA alternativa s√∂ktermer som k√∂pare kan anv√§nda
‚Ä¢ Exempel: Om titel s√§ger "f√§rglitografi" - anv√§nd INTE "f√§rglitografi" igen

KOMPLETTERANDE S√ñKORD - EXEMPEL:
‚Ä¢ F√∂r konsttryck: "grafik reproduktion konstprint limited-edition"
‚Ä¢ F√∂r m√•lningar: "oljem√•lning akvarell konstverk originalverk"  
‚Ä¢ F√∂r skulptur: "skulptur plastik konstf√∂rem√•l tredimensionell"
‚Ä¢ F√∂r m√∂bler: "vintage retro funktionalism dansk-design"
‚Ä¢ F√∂r perioder: Anv√§nd decennier ist√§llet f√∂r exakta √•r: "1970-tal" ist√§llet av "1974"

OBLIGATORISK AUCTIONET FORMAT:
‚Ä¢ Separera s√∂kord med MELLANSLAG (ALDRIG kommatecken)
‚Ä¢ Anv√§nd "-" f√∂r flerordsfraser: "svensk-design", "1970-tal", "limited-edition"
‚Ä¢ EXEMPEL KORREKT: "grafik reproduktion svensk-design 1970-tal konstprint"
‚Ä¢ EXEMPEL FEL: "grafik, reproduktion, svensk design, 1970-tal" (kommatecken och mellanslag i fraser)

KRITISKT - RETURFORMAT:
‚Ä¢ Returnera ENDAST s√∂korden separerade med mellanslag
‚Ä¢ INGA kommatecken mellan s√∂kord
‚Ä¢ INGA f√∂rklaringar, kommentarer eller etiketter
‚Ä¢ MAX 10-12 relevanta termer
‚Ä¢ EXEMPEL: "grafik reproduktion svensk-design 1970-tal dekor inredning"

STRIKT REGEL: L√§s titel och beskrivning noggrant - om ett ord redan finns d√§r, anv√§nd det ALDRIG i s√∂korden.`;
    }
  }

  parseClaudeResponse(response, fieldType) {
    console.log('Parsing Claude response for fieldType:', fieldType, 'Response:', response);
    
    // Validate input
    if (!response || typeof response !== 'string') {
      console.error('Invalid response format:', response);
      throw new Error('Invalid response format from Claude');
    }
    
    // For single field requests, parse the structured response
    if (['title', 'description', 'condition', 'keywords'].includes(fieldType)) {
      const result = {};
      const lines = response.split('\n');
      
      lines.forEach(line => {
        const trimmedLine = line.trim();
        
        if (trimmedLine.match(/^\*?\*?TITEL\s*:?\*?\*?\s*/i)) {
          result.title = trimmedLine.replace(/^\*?\*?TITEL\s*:?\*?\*?\s*/i, '').trim();
        } else if (trimmedLine.match(/^\*?\*?BESKRIVNING\s*:?\*?\*?\s*/i)) {
          result.description = trimmedLine.replace(/^\*?\*?BESKRIVNING\s*:?\*?\*?\s*/i, '').trim();
        } else if (trimmedLine.match(/^\*?\*?KONDITION\s*:?\*?\*?\s*/i)) {
          result.condition = trimmedLine.replace(/^\*?\*?KONDITION\s*:?\*?\*?\s*/i, '').trim();
        } else if (trimmedLine.match(/^\*?\*?S√ñKORD\s*:?\*?\*?\s*/i)) {
          result.keywords = trimmedLine.replace(/^\*?\*?S√ñKORD\s*:?\*?\*?\s*/i, '').trim();
        }
      });
      
      // If no structured response found, treat as legacy format
      if (Object.keys(result).length === 0) {
        result[fieldType] = response.trim();
      }
      
      console.log('Single field parsed result:', result);
      return result;
    }
    
    // Parse the structured response from Claude for multi-field requests
    const result = {};
    const lines = response.split('\n');
    
    lines.forEach(line => {
      const trimmedLine = line.trim();
      
      // Handle different formats: "TITEL:", "**TITEL:**", "**TITEL (XX tecken):**"
      if (trimmedLine.match(/^\*?\*?TITEL(\s*\([^)]*\))?\s*:?\*?\*?\s*/i)) {
        result.title = trimmedLine.replace(/^\*?\*?TITEL(\s*\([^)]*\))?\s*:?\*?\*?\s*/i, '').trim();
      } else if (trimmedLine.match(/^\*?\*?BESKRIVNING\s*:?\*?\*?\s*/i)) {
        result.description = trimmedLine.replace(/^\*?\*?BESKRIVNING\s*:?\*?\*?\s*/i, '').trim();
      } else if (trimmedLine.match(/^\*?\*?KONDITION(SRAPPORT)?\s*:?\*?\*?\s*/i)) {
        result.condition = trimmedLine.replace(/^\*?\*?KONDITION(SRAPPORT)?\s*:?\*?\*?\s*/i, '').trim();
      } else if (trimmedLine.match(/^\*?\*?S√ñKORD\s*:?\*?\*?\s*/i)) {
        result.keywords = trimmedLine.replace(/^\*?\*?S√ñKORD\s*:?\*?\*?\s*/i, '').trim();
      } else if (trimmedLine.match(/^\*?\*?VALIDERING\s*:?\*?\*?\s*/i)) {
        result.validation = trimmedLine.replace(/^\*?\*?VALIDERING\s*:?\*?\*?\s*/i, '').trim();
      }
      
      // Handle simple formats (legacy)
      else if (trimmedLine.startsWith('TITEL:')) {
        result.title = trimmedLine.substring(6).trim();
      } else if (trimmedLine.startsWith('BESKRIVNING:')) {
        result.description = trimmedLine.substring(12).trim();
      } else if (trimmedLine.startsWith('KONDITION:')) {
        result.condition = trimmedLine.substring(10).trim();
      } else if (trimmedLine.startsWith('S√ñKORD:')) {
        result.keywords = trimmedLine.substring(7).trim();
      } else if (trimmedLine.startsWith('VALIDERING:')) {
        result.validation = trimmedLine.substring(11).trim();
      }
    });
    
    // If we only got a simple response (like just a title), handle it appropriately
    if (Object.keys(result).length === 0 && response.trim().length > 0) {
      // Assume it's a single field response based on the request type
      result.title = response.trim();
    }
    
    console.log('Multi-field parsed result:', result);
    
    // Validate the response against Swedish auction standards
    const validation = this.validateSwedishAuctionStandards(result);
    
    // If validation fails, retry once with corrections
    if (validation.score < 70) {
      result.needsCorrection = true;
      result.validationErrors = validation.errors;
      result.validationWarnings = validation.warnings;
      result.validationScore = validation.score;
    }
    
    return result;
  }

  applyImprovement(fieldType, value) {
    const fieldMap = {
      'title': '#item_title_sv',
      'description': '#item_description_sv',
      'condition': '#item_condition_sv',
      'keywords': '#item_hidden_keywords'
    };
    
    const field = document.querySelector(fieldMap[fieldType]);
    if (field && value) {
      // Set programmatic update flag for AI improvements
      this.isProgrammaticUpdate = true;
      
      try {
        field.value = value;
        field.dispatchEvent(new Event('change', { bubbles: true }));
        field.classList.add('ai-updated');
        
        // Auto-resize textarea if needed (especially for description)
        if (field.tagName.toLowerCase() === 'textarea') {
          // Use setTimeout to ensure the value is fully applied before resizing
          setTimeout(() => {
            this.autoResizeTextarea(field);
          }, 50);
        }
        
        console.log(`‚úÖ Applied improvement to ${fieldType}`);
      } finally {
        // Clear flag after a short delay to ensure all events have processed
        setTimeout(() => {
          this.isProgrammaticUpdate = false;
          console.log('üîì Cleared programmatic update flag after AI improvement');
        }, 100);
      }
    }
  }

  // NEW: Auto-resize textarea functionality (from Add Items page)
  autoResizeTextarea(textarea) {
    if (!textarea || textarea.tagName.toLowerCase() !== 'textarea') return;
    
    // Reset height to auto to get the scroll height
    textarea.style.height = 'auto';
    
    // Calculate the height needed
    const scrollHeight = textarea.scrollHeight;
    const minHeight = 60; // Minimum height
    const maxHeight = 400; // Maximum height
    
    // Set the new height within bounds
    const newHeight = Math.max(minHeight, Math.min(scrollHeight, maxHeight));
    textarea.style.height = newHeight + 'px';
    
    // Add resizing class for smooth animation
    textarea.classList.add('resizing');
    setTimeout(() => {
      textarea.classList.remove('resizing');
    }, 300);
  }

  validateAndLimitKeywords(keywords) {
    if (!keywords || typeof keywords !== 'string') {
      return keywords;
    }
    
    // Support both formats: detect if comma-separated or space-separated
    let keywordArray;
    if (keywords.includes(',')) {
      // Comma-separated format - convert to Auctionet format
      keywordArray = keywords.split(',')
        .map(kw => kw.trim())
        .filter(kw => kw.length > 0)
        .filter(kw => kw.length >= 3)
        .map(kw => kw.replace(/\s+/g, '-')); // Convert spaces to hyphens
    } else {
      // Already in Auctionet space-separated format
      keywordArray = keywords.split(/\s+/)
        .map(kw => kw.trim())
        .filter(kw => kw.length > 0)
        .filter(kw => kw.length >= 3);
    }
    
    // If too many keywords, keep only the first 12 (most relevant ones)
    if (keywordArray.length > 12) {
      console.warn(`Too many keywords (${keywordArray.length}), limiting to 12`);
      const limitedKeywords = keywordArray.slice(0, 12);
      return limitedKeywords.join(' '); // Auctionet space-separated format
    }
    
    return keywordArray.join(' '); // Auctionet space-separated format
  }

  addAIEnhancementNote(fieldType) {
    const internalCommentsField = document.querySelector('#item_internal_comment');
    if (internalCommentsField) {
      const currentComments = internalCommentsField.value;
      const timestamp = new Date().toLocaleDateString('sv-SE');
      const fieldNames = {
        'title': 'titel',
        'description': 'beskrivning', 
        'condition': 'kondition',
        'keywords': 's√∂kord'
      };
      
      const enhancementNote = `AI-f√∂rb√§ttring ${fieldNames[fieldType]} (${timestamp})`;
      
      // Check if this enhancement is already noted
      if (!currentComments.includes(enhancementNote)) {
        const newComments = currentComments ? 
          `${currentComments}\n${enhancementNote}` : 
          enhancementNote;
        internalCommentsField.value = newComments;
      }
    }
  }

  addUndoButton(field) {
    const existingUndo = field.parentElement.querySelector('.ai-undo-button');
    if (existingUndo) {
      existingUndo.remove();
    }
    
    const undoButton = document.createElement('button');
    undoButton.className = 'ai-undo-button';
    undoButton.textContent = '‚Ü© √Öngra';
    undoButton.type = 'button';
    
    undoButton.addEventListener('click', () => {
      field.value = field.dataset.originalValue;
      field.classList.remove('ai-updated');
      undoButton.remove();
    });
    
    field.parentElement.appendChild(undoButton);
  }





  getEncouragingMessage(fieldType) {
    const messages = {
      all: [
        "üß† AI analyserar alla f√§lt f√∂r optimal kvalitet...",
        "‚ú® Skapar professionell katalogisering f√∂r alla f√§lt...",
        "üéØ Optimerar hela katalogiseringen f√∂r b√§sta resultat...",
        "üöÄ F√∂rb√§ttrar alla f√§lt med AI-precision..."
      ],
      title: [
        "üéØ Skapar perfekt titel med AI-precision...",
        "üìù Optimerar titel f√∂r s√∂kbarhet...",
        "‚ú® Genererar professionell titel...",
        "üè∑Ô∏è F√∂rb√§ttrar titel enligt auktionsstandard..."
      ],
      description: [
        "üìñ Skapar detaljerad beskrivning...",
        "üîç Analyserar alla detaljer f√∂r beskrivning...",
        "‚ú® Optimerar beskrivning f√∂r kvalitet...",
        "üìã Genererar professionell beskrivning..."
      ],
      condition: [
        "üîß Analyserar kondition professionellt...",
        "üìä Skapar detaljerad konditionsrapport...",
        "‚úÖ Optimerar konditionsbeskrivning...",
        "üîç Genererar noggrann konditionsanalys..."
      ],
      keywords: [
        "üîç Genererar optimala s√∂kord...",
        "üè∑Ô∏è Skapar tr√§ffs√§kra keywords...",
        "üìà Optimerar s√∂kbarhet...",
        "üéØ F√∂rb√§ttrar s√∂ktrafik med smarta ord..."
      ]
    };
    
    const messageArray = messages[fieldType] || messages.all;
    return messageArray[Math.floor(Math.random() * messageArray.length)];
  }

  showFieldLoadingIndicator(fieldType) {
    return this.showLoadingIndicator(fieldType);
  }

  showLoadingIndicator(fieldType) {
    console.log(`üîÑ Loading indicator for ${fieldType}`);
    
    // Remove any existing loading states
    this.removeFieldLoadingIndicator(fieldType);
    
    let targetField;
    if (fieldType === 'all') {
      // For "all" - show loading on master button AND all individual fields
      const masterButton = document.querySelector('.ai-master-button');
      if (masterButton) {
        masterButton.textContent = 'üß† AI arbetar...';
        masterButton.disabled = true;
        masterButton.style.opacity = '0.7';
      }
      
      // Show loading animation on all fields simultaneously
      const allFieldTypes = ['title', 'description', 'condition', 'keywords'];
      allFieldTypes.forEach(type => {
        this.showFieldLoadingIndicator(type);
      });
      return;
    } else {
      // Get the specific field
      const fieldMap = {
        'title': '#item_title_sv',
        'description': '#item_description_sv', 
        'condition': '#item_condition_sv',
        'keywords': '#item_hidden_keywords'
      };
      
      targetField = document.querySelector(fieldMap[fieldType]);
      console.log(`üéØ Target field for ${fieldType}:`, targetField);
      console.log(`üìã Field element details:`, {
        id: targetField?.id,
        tagName: targetField?.tagName,
        className: targetField?.className,
        parentElement: targetField?.parentElement?.className
      });
    }
    
    if (!targetField) {
      console.error(`‚ùå Target field not found for ${fieldType}`);
      return;
    }
    
    // Add CSS for field spinner overlays if not already added
    if (!document.getElementById('field-spinner-overlay-styles')) {
      const style = document.createElement('style');
      style.id = 'field-spinner-overlay-styles';
      style.textContent = `
        /* AI Field Enhancement Loading States - EXACT COPY FROM ADD ITEMS PAGE */
        .field-loading {
          position: relative;
        }
        
        .field-loading input,
        .field-loading textarea {
          filter: blur(2px);
          transition: filter 0.3s ease;
          pointer-events: none;
        }
        
        .field-spinner-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(255, 255, 255, 0.8);
          backdrop-filter: blur(1px);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          border-radius: 6px;
          animation: overlayFadeIn 0.3s ease;
        }
        
        .ai-spinner {
          width: 24px;
          height: 24px;
          border: 2px solid #e5e7eb;
          border-top: 2px solid #007bff;
          border-radius: 50%;
          animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        .ai-processing-text {
          margin-left: 12px;
          font-size: 13px;
          color: #374151;
          font-weight: 500;
          letter-spacing: 0.025em;
        }
        
        @keyframes overlayFadeIn {
          from {
            opacity: 0;
            transform: scale(0.95);
          }
          to {
            opacity: 1;
            transform: scale(1);
          }
        }
        
        /* Success flash animation - EXACT COPY FROM ADD ITEMS PAGE */
        .field-success {
          animation: successFlash 0.6s ease;
        }
        
        @keyframes successFlash {
          0% { 
            background-color: rgba(34, 197, 94, 0.1);
            border-color: #22c55e;
          }
          50% { 
            background-color: rgba(34, 197, 94, 0.2);
            border-color: #16a34a;
          }
          100% { 
            background-color: transparent;
            border-color: initial;
          }
        }
        
        /* Auto-resize textarea styling with smooth transitions */
        textarea.auto-resize {
          resize: vertical;
          min-height: 60px;
          max-height: 400px;
          transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          overflow-y: auto;
        }
        
        textarea.auto-resize:not(:focus) {
          overflow-y: hidden;
        }
        
        .auto-resize.resizing {
          transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        }
      `;
      document.head.appendChild(style);
      console.log('‚úÖ Field spinner overlay styles added');
    }
    
    // Find the field container (parent element that will hold the overlay)
    let fieldContainer = targetField.parentElement;
    console.log(`üè† Initial field container:`, {
      element: fieldContainer,
      className: fieldContainer?.className,
      tagName: fieldContainer?.tagName
    });
    
    // For textareas and inputs, we might need to go up one more level if it's in a wrapper
    if (fieldContainer.classList.contains('ai-button-wrapper') || fieldContainer.tagName === 'LABEL') {
      fieldContainer = fieldContainer.parentElement;
      console.log(`üè† Adjusted field container:`, {
        element: fieldContainer,
        className: fieldContainer?.className,
        tagName: fieldContainer?.tagName
      });
    }
    
    // Check if container has position: relative or set it
    const containerStyle = window.getComputedStyle(fieldContainer);
    if (containerStyle.position === 'static') {
      fieldContainer.style.position = 'relative';
      console.log('üîß Set field container position to relative');
    }
    
    // Add loading class to container
    fieldContainer.classList.add('field-loading');
    console.log(`‚úÖ Added field-loading class to container`);
    
    // Create spinner overlay
    const overlay = document.createElement('div');
    overlay.className = 'field-spinner-overlay';
    overlay.dataset.fieldType = fieldType;
    overlay.innerHTML = `
      <div class="ai-spinner"></div>
      <div class="ai-processing-text">AI f√∂rb√§ttrar...</div>
    `;
    
    // Position overlay over the field
    const fieldRect = targetField.getBoundingClientRect();
    const containerRect = fieldContainer.getBoundingClientRect();
    
    console.log(`üìê Field positioning:`, {
      fieldRect: {
        top: fieldRect.top,
        left: fieldRect.left,
        width: fieldRect.width,
        height: fieldRect.height
      },
      containerRect: {
        top: containerRect.top,
        left: containerRect.left,
        width: containerRect.width,
        height: containerRect.height
      }
    });
    
    // Calculate relative position
    const relativeTop = fieldRect.top - containerRect.top;
    const relativeLeft = fieldRect.left - containerRect.left;
    
    overlay.style.position = 'absolute';
    overlay.style.top = `${relativeTop}px`;
    overlay.style.left = `${relativeLeft}px`;
    overlay.style.width = `${fieldRect.width}px`;
    overlay.style.height = `${fieldRect.height}px`;
    
    console.log(`üìê Overlay positioning:`, {
      position: 'absolute',
      top: `${relativeTop}px`,
      left: `${relativeLeft}px`,
      width: `${fieldRect.width}px`,
      height: `${fieldRect.height}px`
    });
    
    // Add overlay to container
    fieldContainer.appendChild(overlay);
    
    console.log(`‚úÖ Loading animation overlay added to ${fieldType} field`);
    console.log(`üîç Overlay element:`, overlay);
    console.log(`üè† Container with overlay:`, fieldContainer);
  }

  showFieldSuccessIndicator(fieldType) {
    console.log(`‚úÖ Success indicator for ${fieldType}`);
    
    // Remove loading state
    this.removeFieldLoadingIndicator(fieldType);
    
    if (fieldType === 'all') {
      // Reset master button
      const masterButton = document.querySelector('.ai-master-button');
      if (masterButton) {
        masterButton.textContent = '‚úÖ Klart!';
        setTimeout(() => {
          masterButton.textContent = '‚ö° F√∂rb√§ttra alla';
          masterButton.disabled = false;
          masterButton.style.opacity = '1';
        }, 2000);
      }
      return;
    }
    
    // Get the specific field and apply success flash
    const fieldMap = {
      'title': '#item_title_sv',
      'description': '#item_description_sv',
      'condition': '#item_condition_sv', 
      'keywords': '#item_hidden_keywords'
    };
    
    const targetField = document.querySelector(fieldMap[fieldType]);
    if (targetField) {
      targetField.classList.add('field-success');
      
      // Remove success class after animation
      setTimeout(() => {
        targetField.classList.remove('field-success');
      }, 600);
    }
  }

  showFieldErrorIndicator(fieldType, message) {
    console.error(`‚ùå Error for ${fieldType}: ${message}`);
    
    // Remove loading state
    this.removeFieldLoadingIndicator(fieldType);
    
    if (fieldType === 'all') {
      // Reset master button
      const masterButton = document.querySelector('.ai-master-button');
      if (masterButton) {
        masterButton.textContent = '‚ùå Fel uppstod';
        masterButton.disabled = false;
        masterButton.style.opacity = '1';
        setTimeout(() => {
          masterButton.textContent = '‚ö° F√∂rb√§ttra alla';
        }, 3000);
      }
    }
    
    // Show error message
    alert(`Fel vid AI-f√∂rb√§ttring av ${fieldType}: ${message}`);
  }
  
  removeFieldLoadingIndicator(fieldType) {
    if (fieldType === 'all') {
      // Remove loading from all individual fields
      const allFieldTypes = ['title', 'description', 'condition', 'keywords'];
      allFieldTypes.forEach(type => {
        this.removeFieldLoadingIndicator(type);
      });
      return;
    }
    
    // Remove loading states for specific field type
    const overlay = document.querySelector(`.field-spinner-overlay[data-field-type="${fieldType}"]`);
    if (overlay) {
      const container = overlay.parentElement;
      container.classList.remove('field-loading');
      overlay.remove();
    }
    
    // Also remove any general loading classes
    document.querySelectorAll('.field-loading').forEach(container => {
      const overlays = container.querySelectorAll('.field-spinner-overlay');
      if (overlays.length === 0) {
        container.classList.remove('field-loading');
      }
    });
  }
}

// Initialize when DOM is ready
console.log('üé¨ Extension script executing, document ready state:', document.readyState);

if (document.readyState === 'loading') {
  console.log('‚è≥ Document still loading, waiting for DOMContentLoaded...');
  document.addEventListener('DOMContentLoaded', () => {
    console.log('‚úÖ DOMContentLoaded fired, creating AuctionetCatalogingAssistant');
    window.auctionetAssistant = new AuctionetCatalogingAssistant();
  });
} else {
  console.log('‚úÖ Document already loaded, creating AuctionetCatalogingAssistant immediately');
  window.auctionetAssistant = new AuctionetCatalogingAssistant();
}